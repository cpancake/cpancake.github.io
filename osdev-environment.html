<!DOCTYPE html>
<html>
    <head>
        <title>OS Dev Environment Setup - andrew rogers: programming stuff</title>
        <meta charset="utf-8" />
        <link href="/theme/css/bootstrap.min.css" rel="stylesheet" />
        <link href="/theme/css/pygments.css" rel="stylesheet" />
        <link href="/theme/css/style.css" rel="stylesheet" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    </head>

    <body id="index" class="archive">
        <div class="container">
            <div class="header">
                <ul class="nav nav-pills pull-right">
                    <li class=""><a href="/">Home</a></li>
                    <li><a href="/archives.html">Archives</a></li>
                </ul>
                <h3 class="text-muted"><a href="/">andrew rogers: programming stuff</a></h3>
				<h2 class="text-muted"></h2>
             </div>
<section id="content" class="article content">
  <header>
    <h2 class="entry-title">
      <a href="/osdev-environment.html" rel="bookmark"
         title="Permalink to OS Dev Environment Setup">OS Dev Environment Setup</a></h2>
 
    <div class="post-info text-muted">
      Posted on <abbr class="published" title="2014-05-22T21:07:00">
        Thu 22 May 2014
      </abbr>
      <address class="vcard author">
        by <a class="url fn" href="/author/cpancake.html">cpancake</a>
      </address> in <a href="/category/posts.html">Posts</a> 
      Tagged <a href="/tag/programming.html">programming </a><a href="/tag/osdev.html">osdev </a>    </div><!-- /.post-info -->
  </header>
     
  <div class="entry-content">
    <p><a href="/osdev-gcc.html">Last post</a>, I showed you how to cross-compile GCC for operating system development. Today, I'm going to get you all set up to write your own operating system, from scratch. We're going to be calling this example operating system "Helios", because it ends with OS.</p>
<h2>Preparation</h2>
<p>The most important tool here that you don't already have is <a href="http://nasm.us/">NASM</a>. NASM, or the Netwide Assembler, is key to operating system development. You can't write an operating system without writing some Assembly, and there's no better assembler than NASM. Download and install NASM (I recommend the installer, but you can do whatever as long as you put it in the PATH). </p>
<p>Another tool you're going to need is <code>mkisofs</code>. This is a tool to make ISOs from binaries, and it's going to be used to generate the ISO we'll emulate from. You can install it from the Cygwin installer (you can just run it again and select other packages, it won't do any harm), or find one of the many unofficial Windows ports online. </p>
<p>The final tool you'll need is the emulator to test this. I recommend <a href="http://bochs.sourceforge.net/">Bochs</a>, and it's what I'll be using for the duration of this project. Download and run the installer, and then add the Bochs installation directory to your path (so that typing in <code>bochs</code> launches the emulator; if you don't know how to do this, just leave a comment).</p>
<p>Now, create a directory to hold your project. I suggest having two folders inside - <code>disk</code> and <code>src</code>. Then, in the root of this folder, place a file called .bochsrc with the following in it:</p>
<div class="highlight"><pre><span class="n">ata0</span><span class="o">:</span> <span class="n">enabled</span><span class="o">=</span><span class="mi">1</span><span class="o">,</span> <span class="n">ioaddr1</span><span class="o">=</span><span class="mh">0x1f0</span><span class="o">,</span> <span class="n">ioaddr2</span><span class="o">=</span><span class="mh">0x3f0</span><span class="o">,</span> <span class="n">irq</span><span class="o">=</span><span class="mi">14</span>
<span class="n">ata0</span><span class="o">-</span><span class="n">master</span><span class="o">:</span> <span class="n">type</span><span class="o">=</span><span class="n">cdrom</span><span class="o">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;disk/helios.iso&quot;</span><span class="o">,</span> <span class="n">status</span><span class="o">=</span><span class="n">inserted</span>
<span class="n">boot</span><span class="o">:</span> <span class="n">cdrom</span>
</pre></div>


<p>This file, when you launch bochs, will tell it to create a virtual CD drive from the ISO of our operating system, and to boot from it. This is vital.</p>
<h2>Basic OS</h2>
<p>This is an OS down to its simplest form. This will tell you if your setup works. In the src directory, create the file <code>boot.asm</code>, with the following contents:</p>
<div class="highlight"><pre><span class="c1">; Kernel&#39;s entry point. </span>
<span class="c1">; This is what GRUB calls when it hands control to the OS</span>
<span class="err">[</span><span class="k">BITS</span> <span class="mi">32</span><span class="p">]</span>
<span class="k">global</span> <span class="nv">start</span>
<span class="nl">start:</span>
    <span class="nf">mov</span> <span class="nb">esp</span><span class="p">,</span> <span class="nv">_sys_stack</span> <span class="c1">; Set the stack pointer to point to the top of our stack.</span>
    <span class="nf">jmp</span> <span class="nv">stublet</span>

<span class="c1">; The multiboot header. GRUB looks for this before it boots the OS.</span>
<span class="k">ALIGN</span> <span class="mi">4</span>
<span class="nl">mboot:</span>
    <span class="no">MULTIBOOT_PAGE_ALIGN</span><span class="kd">    equ</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span>
    <span class="no">MULTIBOOT_MEMORY_INFO</span><span class="kd">   equ</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span>
    <span class="no">MULTIBOOT_HEADER_MAGIC</span><span class="kd">  equ</span> <span class="mh">0x1BADB002</span>
    <span class="no">MULTIBOOT_HEADER_FLAGS</span><span class="kd">  equ</span> <span class="nv">MULTIBOOT_PAGE_ALIGN</span> <span class="o">|</span> <span class="nv">MULTIBOOT_MEMORY_INFO</span>
    <span class="no">MULTIBOOT_CHECKSUM</span><span class="kd">  equ</span> <span class="o">-</span><span class="p">(</span><span class="nv">MULTIBOOT_HEADER_MAGIC</span> <span class="o">+</span> <span class="nv">MULTIBOOT_HEADER_FLAGS</span><span class="p">)</span>

    <span class="kd">dd</span> <span class="nv">MULTIBOOT_HEADER_MAGIC</span>
    <span class="kd">dd</span> <span class="nv">MULTIBOOT_HEADER_FLAGS</span>
    <span class="kd">dd</span> <span class="nv">MULTIBOOT_CHECKSUM</span>

<span class="c1">; Call the kernel, then enter an infinite loop.</span>
<span class="nl">stublet:</span>
    <span class="k">extern</span> <span class="nv">kernel</span>
    <span class="nf">call</span> <span class="nv">kernel</span>
    <span class="nf">jmp</span> <span class="kc">$</span> <span class="c1">; Infinite loop</span>

<span class="k">SECTION</span> <span class="nv">.bss</span>
    <span class="kd">resb</span> <span class="mi">8192</span>
<span class="nl">_sys_stack:</span>
</pre></div>


<p>Theres a few comments in this file, but most of it is GRUB specific stuff. Basically, we're telling GRUB "Hey, we're an operating system, feel free to boot us!" It also initializes the stack and points the stack pointer to it, and calls our kernel. But where is this kernel defined? We use an <code>extern</code> statement to tell the compiler that it shouldn't complain when it doesn't exist. Then, we define the <code>kernel</code> function in a C file. Name it <code>main.c</code> and put this in it:</p>
<div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> 
<span class="kt">int</span> <span class="n">kernel</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This just returns "DEADBEEF" when called. You'll see why when we run it. But why the <code>extern</code> statement here? Technically, we're using G++ for this, which <a href="http://en.wikipedia.org/wiki/Name_mangling">mangles</a> the names of its functions when compiled. To be able to call this from assembly reliably, we have to tell G++ that it's a C function and shouldn't be messed with. Keep in mind that, even though we're writing this in C, you don't have access to <em>any</em> of the C standard library. We'll need to implement everything ourselves. </p>
<h2>Compiling</h2>
<p>We're going to use Makefiles to compile this, because they're really useful and are much less ugly than batch files. First, create a Makefile in the src directory:</p>
<div class="highlight"><pre><span class="nv">OBJS</span><span class="o">=</span>main.o boot.o
<span class="nv">OUT</span><span class="o">=</span>kernel.bin

<span class="nf">all</span><span class="o">:</span> <span class="m">objects kernel</span>
    rm -rf *.o
    mv kernel.bin ../disk/files/boot

<span class="nf">objects</span><span class="o">:</span> <span class="m">$(OBJS)</span>

<span class="nf">%.o</span><span class="o">:</span> <span class="m">%.asm</span>
    nasm -felf <span class="nv">$&lt;</span> -o <span class="nv">$@</span>

<span class="nf">%.o</span><span class="o">:</span> <span class="m">%.c %.cpp %.cc</span>
    i386-elf-g++ -ffreestanding -O2 -Wall -Wextra -fno-exceptions -fno-rtti -c <span class="nv">$&lt;</span>

<span class="nf">kernel</span><span class="o">:</span> 
    i386-elf-ld -T link.ld -o kernel.bin <span class="k">$(</span>OBJS<span class="k">)</span>

<span class="nf">clean</span><span class="o">:</span> 
    rm -rf <span class="k">$(</span>OBJS<span class="k">)</span>
    rm -rf ../disk/files/boot/kernel.bin
</pre></div>


<p>If you don't understand this, you should probably read up on how Makefiles work (because they're <em>really</em> useful), but it's actually pretty simple. We define what objects we need compied (main.o and boot.o), how to compile them based on the source file (main.c is compiled with G++, while boot.asm is compiled with NASM), and then we tell it how to link them together and create a binary for our operating system. We can also run <code>make clean</code> to delete all the binaries we've already compiled and start fresh.</p>
<h2>GRUB and ISOs</h2>
<p>This Makefile isn't complete yet, however. First, the directory <code>../disk/files/boot</code> doesn't exist yet. Second, there's no way to create the ISO. We'll solve these together. First, you'll need to create the directory <code>files</code> inside <code>disk</code>, <code>boot</code> inside of that, and <code>grub</code> inside of that. Then, place the file <code>menu.lst</code> in the <code>grub</code> directory, and put this in it:</p>
<div class="highlight"><pre><span class="k">default</span> <span class="mi">0</span>

<span class="n">title</span> <span class="n">Helios</span>
<span class="n">kernel</span> <span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">kernel</span><span class="p">.</span><span class="n">bin</span>
</pre></div>


<p>This will tell GRUB which operating system to start. We tell it to start /boot/kernel.bin, because the root of our ISO is going to be <code>disk/files</code>, and kernel.bin will be in the <code>boot</code> directory. You'll also need to put <a href="https://code.google.com/p/arabos/downloads/detail?name=stage2_eltorito">this</a> file in the <code>grub</code> directory. This is GRUB itself, and we will use it to create the ISO.</p>
<p>Now, remember how we installed <code>mkisofs</code> back in the beginning? Here's why. Add this to the end of your Makefile:</p>
<div class="highlight"><pre><span class="nf">iso</span><span class="o">:</span>
    mkisofs -R -b boot/grub/stage2_eltorito -no-emul-boot <span class="se">\</span>
            -boot-load-size 4 -boot-info-table -V HELIOS <span class="se">\</span>
            -quiet -o ../disk/helios.iso ../disk/files
</pre></div>


<p>This can be broken down into its arguments. <code>-R</code> tells <code>mkisofs</code> to create the ISO with <a href="http://en.wikipedia.org/wiki/Rock_Ridge">Rock Ridge</a> directory information; <code>-b</code> tells it to boot from <code>stage2_eltorito</code> (which is GRUB); <code>-no-emul-boot</code> tells it to boot from the GRUB image we provided; <code>-boot-load-size 4</code> tells it that the BIOS should load 2048 bytes of the ISO when booting from it (four 512-byte sectors); <code>-boot-info-table</code> tells GRUB a little bit about the ISO it's booting; <code>-V HELIOS</code> sets the label of the ISO to <code>HELIOS</code>, <code>-quiet</code> tells it not to say anything unless something goes wrong; <code>-o ../disk/helios.iso</code> tells it where to output the ISO, and <code>../disk/files</code> tells it to make the ISO from the files contained there. Now, when you run <code>make iso</code>, an ISO will be created in <code>disk</code>. Are we done? Not quite.</p>
<h2>Bringing It All Together</h2>
<p>We'll also create a Makefile in the root of our directory to help automate the process. Here's what's contained in mine:</p>
<div class="highlight"><pre><span class="nf">all</span><span class="o">:</span> <span class="m">build run</span>

<span class="nf">build</span><span class="o">:</span> 
    <span class="nb">cd </span>src <span class="o">&amp;&amp;</span> make <span class="o">&amp;&amp;</span> make iso <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ..

<span class="nf">run</span><span class="o">:</span> 
    bochs -f .bochsrc
</pre></div>


<p>It's simple and short. When you run <code>make</code> in the root directory, it will build and run your operating system. If you only need to run it, you can use <code>make run</code>. If you only need to build it, you can use <code>make build</code>.</p>
<p>Now, run the code via <code>make</code>. Press "start" in Bochs, press enter in GRUB, and then Bochs will hang. Don't worry, that's because we put in an infinite loop. Just press shutdown. The output console will display the registers when Bochs shutdown. Check the value of EAX, which is the return value of our C function. Is it <code>deadbeef</code>? If so, good job, your code is working!</p>
<p>That's it for this tutorial. Next time, we'll get into displaying stuff on screen and other important bits. From this point on, all the code is available on <a href="http://github.com/cpancake/helios">GitHub</a>, so watch that repository if you want an update when I publish a new post. Until next time!</p>
  </div><!-- /.entry-content -->
</section>
    <div class="comment">
        <div id="disqus_thread"></div> <!-- comment app container -->
    </div>
	<!-- Comment BEGIN -->
    <script type="text/javascript">
        var disqus_shortname = 'commiesprogblog'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
     <!-- Comment END -->
            <footer id="contentinfo" class="footer">
                    <nav class="pull-right bottom-nav">
                        <a href="/None">RSS</a>
                    </nav>
                    <address id="about" class="vcard body">
                    &copy; <a href="">andrew rogers: programming stuff</a> Proudly powered by <a href="http://getpelican.com/">Pelican</a>
                    </address><!-- /#about -->
            </footer><!-- /#contentinfo -->
        </div><!-- container -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
	var pageTracker = _gat._getTracker("UA-51284727-1");
pageTracker._trackPageview();
} catch(err) {}</script>
    </body>
</html>