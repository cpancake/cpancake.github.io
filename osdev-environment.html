<!DOCTYPE html>
<html lang="en">
<head>
          <title>andrew rogers: programming stuff</title>
        <meta charset="utf-8" />
        <link href='http://fonts.googleapis.com/css?family=Montserrat:700|Roboto+Condensed:400italic,400,700' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/theme/css/bootstrap.min.css?698b47d4">
        <link rel="stylesheet" href="/theme/css/style.min.css?4f87944c">



    <meta name="tags" contents="programming" />
    <meta name="tags" contents="osdev" />

</head>

<body id="index" class="home">
    <header id="banner" class="body">
            <h1><a class="uilink" href="/">andrew rogers: programming stuff <strong></strong></a></h1>
    </header><!-- /#banner -->
    <nav id="menu">
        <ul>
            <li><a class="uilink" href="/">Home</a></li>
            <li><a class="uilink" href="http://github.com/cpancake">GitHub</a></li>
            <li><a class="uilink" href="https://twitter.com/_cpancake">Twitter</a></li>
        </ul>
    </nav><!-- /#menu -->
    <div class="container main-container">
<section id="content" class="body">
  <header>
    <h2 class="entry-title">OS Dev Environment Setup</h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2014-05-22T21:07:00-04:00">Thu 22 May 2014</abbr>
    <address class="vcard author">
      by           <a class="url fn" href="/author/andrew-rogers.html">Andrew Rogers</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p><strong>This series has been discontinued in favor of the far superior <a href="http://littleosbook.github.io/">Little OS Book</a>. Take a look at that one if you want to develop an operating system!</strong></p>
<p><a href="/osdev-gcc.html">Last post</a>, I showed you how to cross-compile GCC for operating system development. Today, I'm going to get you all set up to write your own operating system, from scratch. We're going to be calling this example operating system "Helios", because it ends with OS.</p>
<h2>Preparation</h2>
<p>The most important tool here that you don't already have is <a href="http://nasm.us/">NASM</a>. NASM, or the Netwide Assembler, is key to operating system development. You can't write an operating system without writing some Assembly, and there's no better assembler than NASM. Download and install NASM (I recommend the installer, but you can do whatever as long as you put it in the PATH). </p>
<p>Another tool you're going to need is <code>mkisofs</code>. This is a tool to make ISOs from binaries, and it's going to be used to generate the ISO we'll emulate from. You can install it from the Cygwin installer (you can just run it again and select other packages, it won't do any harm), or find one of the many unofficial Windows ports online. </p>
<p>The final tool you'll need is the emulator to test this. I recommend <a href="http://bochs.sourceforge.net/">Bochs</a>, and it's what I'll be using for the duration of this project. Download and run the installer, and then add the Bochs installation directory to your path (so that typing in <code>bochs</code> launches the emulator; if you don't know how to do this, just leave a comment).</p>
<p>Now, create a directory to hold your project. I suggest having two folders inside - <code>disk</code> and <code>src</code>. Then, in the root of this folder, place a file called .bochsrc with the following in it:</p>
<div class="highlight"><pre><span class="n">ata0</span><span class="o">:</span> <span class="n">enabled</span><span class="o">=</span><span class="mi">1</span><span class="o">,</span> <span class="n">ioaddr1</span><span class="o">=</span><span class="mh">0x1f0</span><span class="o">,</span> <span class="n">ioaddr2</span><span class="o">=</span><span class="mh">0x3f0</span><span class="o">,</span> <span class="n">irq</span><span class="o">=</span><span class="mi">14</span>
<span class="n">ata0</span><span class="o">-</span><span class="n">master</span><span class="o">:</span> <span class="n">type</span><span class="o">=</span><span class="n">cdrom</span><span class="o">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;disk/helios.iso&quot;</span><span class="o">,</span> <span class="n">status</span><span class="o">=</span><span class="n">inserted</span>
<span class="n">boot</span><span class="o">:</span> <span class="n">cdrom</span>
</pre></div>


<p>This file, when you launch bochs, will tell it to create a virtual CD drive from the ISO of our operating system, and to boot from it. This is vital.</p>
<h2>Basic OS</h2>
<p>This is an OS down to its simplest form. This will tell you if your setup works. In the src directory, create the file <code>boot.asm</code>, with the following contents:</p>
<div class="highlight"><pre><span class="c1">; Kernel&#39;s entry point. </span>
<span class="c1">; This is what GRUB calls when it hands control to the OS</span>
<span class="err">[</span><span class="k">BITS</span> <span class="mi">32</span><span class="p">]</span>
<span class="k">global</span> <span class="nv">start</span>
<span class="nl">start:</span>
    <span class="nf">mov</span> <span class="nb">esp</span><span class="p">,</span> <span class="nv">_sys_stack</span> <span class="c1">; Set the stack pointer to point to the top of our stack.</span>
    <span class="nf">jmp</span> <span class="nv">stublet</span>

<span class="c1">; The multiboot header. GRUB looks for this before it boots the OS.</span>
<span class="k">ALIGN</span> <span class="mi">4</span>
<span class="nl">mboot:</span>
    <span class="no">MULTIBOOT_PAGE_ALIGN</span><span class="kd">    equ</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span>
    <span class="no">MULTIBOOT_MEMORY_INFO</span><span class="kd">   equ</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span>
    <span class="no">MULTIBOOT_HEADER_MAGIC</span><span class="kd">  equ</span> <span class="mh">0x1BADB002</span>
    <span class="no">MULTIBOOT_HEADER_FLAGS</span><span class="kd">  equ</span> <span class="nv">MULTIBOOT_PAGE_ALIGN</span> <span class="o">|</span> <span class="nv">MULTIBOOT_MEMORY_INFO</span>
    <span class="no">MULTIBOOT_CHECKSUM</span><span class="kd">  equ</span> <span class="o">-</span><span class="p">(</span><span class="nv">MULTIBOOT_HEADER_MAGIC</span> <span class="o">+</span> <span class="nv">MULTIBOOT_HEADER_FLAGS</span><span class="p">)</span>

    <span class="kd">dd</span> <span class="nv">MULTIBOOT_HEADER_MAGIC</span>
    <span class="kd">dd</span> <span class="nv">MULTIBOOT_HEADER_FLAGS</span>
    <span class="kd">dd</span> <span class="nv">MULTIBOOT_CHECKSUM</span>

<span class="c1">; Call the kernel, then enter an infinite loop.</span>
<span class="nl">stublet:</span>
    <span class="k">extern</span> <span class="nv">kernel</span>
    <span class="nf">call</span> <span class="nv">kernel</span>
    <span class="nf">jmp</span> <span class="kc">$</span> <span class="c1">; Infinite loop</span>

<span class="k">SECTION</span> <span class="nv">.bss</span>
    <span class="kd">resb</span> <span class="mi">8192</span>
<span class="nl">_sys_stack:</span>
</pre></div>


<p>Theres a few comments in this file, but most of it is GRUB specific stuff. Basically, we're telling GRUB "Hey, we're an operating system, feel free to boot us!" It also initializes the stack and points the stack pointer to it, and calls our kernel. But where is this kernel defined? We use an <code>extern</code> statement to tell the compiler that it shouldn't complain when it doesn't exist. Then, we define the <code>kernel</code> function in a C file. Name it <code>main.c</code> and put this in it:</p>
<div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> 
<span class="kt">int</span> <span class="n">kernel</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This just returns "DEADBEEF" when called. You'll see why when we run it. But why the <code>extern</code> statement here? Technically, we're using G++ for this, which <a href="http://en.wikipedia.org/wiki/Name_mangling">mangles</a> the names of its functions when compiled. To be able to call this from assembly reliably, we have to tell G++ that it's a C function and shouldn't be messed with. Keep in mind that, even though we're writing this in C, you don't have access to <em>any</em> of the C standard library. We'll need to implement everything ourselves. </p>
<h2>Compiling</h2>
<p>We're going to use Makefiles to compile this, because they're really useful and are much less ugly than batch files. First, create a Makefile in the src directory:</p>
<div class="highlight"><pre><span class="nv">OBJS</span><span class="o">=</span>main.o boot.o
<span class="nv">OUT</span><span class="o">=</span>kernel.bin

<span class="nf">all</span><span class="o">:</span> <span class="n">objects</span> <span class="n">kernel</span>
    rm -rf *.o
    mv kernel.bin ../disk/files/boot

<span class="nf">objects</span><span class="o">:</span> <span class="k">$(</span><span class="nv">OBJS</span><span class="k">)</span>

<span class="nf">%.o</span><span class="o">:</span> %.<span class="n">asm</span>
    nasm -felf <span class="nv">$&lt;</span> -o <span class="nv">$@</span>

<span class="nf">%.o</span><span class="o">:</span> %.<span class="n">c</span>
    i386-elf-g++ -ffreestanding -O2 -Wall -Wextra -fno-exceptions -fno-rtti -c <span class="nv">$&lt;</span>

<span class="nf">kernel</span><span class="o">:</span> 
    i386-elf-ld -T link.ld -o kernel.bin <span class="k">$(</span>OBJS<span class="k">)</span>

<span class="nf">clean</span><span class="o">:</span> 
    rm -rf <span class="k">$(</span>OBJS<span class="k">)</span>
    rm -rf ../disk/files/boot/kernel.bin
</pre></div>


<p>If you don't understand this, you should probably read up on how Makefiles work (because they're <em>really</em> useful), but it's actually pretty simple. We define what objects we need compied (main.o and boot.o), how to compile them based on the source file (main.c is compiled with G++, while boot.asm is compiled with NASM), and then we tell it how to link them together and create a binary for our operating system. We can also run <code>make clean</code> to delete all the binaries we've already compiled and start fresh.</p>
<h2>GRUB and ISOs</h2>
<p>This Makefile isn't complete yet, however. First, the directory <code>../disk/files/boot</code> doesn't exist yet. Second, there's no way to create the ISO. We'll solve these together. First, you'll need to create the directory <code>files</code> inside <code>disk</code>, <code>boot</code> inside of that, and <code>grub</code> inside of that. Then, place the file <code>menu.lst</code> in the <code>grub</code> directory, and put this in it:</p>
<div class="highlight"><pre>default 0

title Helios
kernel /boot/kernel.bin
</pre></div>


<p>This will tell GRUB which operating system to start. We tell it to start /boot/kernel.bin, because the root of our ISO is going to be <code>disk/files</code>, and kernel.bin will be in the <code>boot</code> directory. You'll also need to put <a href="https://code.google.com/p/arabos/downloads/detail?name=stage2_eltorito">this</a> file in the <code>grub</code> directory. This is GRUB itself, and we will use it to create the ISO.</p>
<p>Now, remember how we installed <code>mkisofs</code> back in the beginning? Here's why. Add this to the end of your Makefile:</p>
<div class="highlight"><pre><span class="nf">iso</span><span class="o">:</span>
    mkisofs -R -b boot/grub/stage2_eltorito -no-emul-boot <span class="se">\</span>
            -boot-load-size <span class="m">4</span> -boot-info-table -V HELIOS <span class="se">\</span>
            -quiet -o ../disk/helios.iso ../disk/files
</pre></div>


<p>This can be broken down into its arguments. <code>-R</code> tells <code>mkisofs</code> to create the ISO with <a href="http://en.wikipedia.org/wiki/Rock_Ridge">Rock Ridge</a> directory information; <code>-b</code> tells it to boot from <code>stage2_eltorito</code> (which is GRUB); <code>-no-emul-boot</code> tells it to boot from the GRUB image we provided; <code>-boot-load-size 4</code> tells it that the BIOS should load 2048 bytes of the ISO when booting from it (four 512-byte sectors); <code>-boot-info-table</code> tells GRUB a little bit about the ISO it's booting; <code>-V HELIOS</code> sets the label of the ISO to <code>HELIOS</code>, <code>-quiet</code> tells it not to say anything unless something goes wrong; <code>-o ../disk/helios.iso</code> tells it where to output the ISO, and <code>../disk/files</code> tells it to make the ISO from the files contained there. Now, when you run <code>make iso</code>, an ISO will be created in <code>disk</code>. Are we done? Not quite.</p>
<h2>Bringing It All Together</h2>
<p>We'll also create a Makefile in the root of our directory to help automate the process. Here's what's contained in mine:</p>
<div class="highlight"><pre><span class="nf">all</span><span class="o">:</span> <span class="n">build</span> <span class="n">run</span>

<span class="nf">build</span><span class="o">:</span> 
    <span class="nb">cd </span>src <span class="o">&amp;&amp;</span> make <span class="o">&amp;&amp;</span> make iso <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ..

<span class="nf">run</span><span class="o">:</span> 
    bochs -f .bochsrc
</pre></div>


<p>It's simple and short. When you run <code>make</code> in the root directory, it will build and run your operating system. If you only need to run it, you can use <code>make run</code>. If you only need to build it, you can use <code>make build</code>.</p>
<p>You'll also need to create a file called <code>link.ld</code> in the <code>src</code> directory. This will tell <code>ld</code> how to link the kernel together:</p>
<div class="highlight"><pre>ENTRY(start)
phys = 0x00100000;
SECTIONS
{
  .text phys : AT(phys) {
    code = .;
    *(.text)
    *(.rodata)
    . = ALIGN(4096);
  }
  .data : AT(phys + (data - code))
  {
    data = .;
    *(.data)
    . = ALIGN(4096);
  }
  .bss : AT(phys + (bss - code))
  {
    bss = .;
    *(.bss)
    . = ALIGN(4096);
  }
  end = .;
}
</pre></div>


<p>Now, run the code via <code>make</code> (make sure you're running <code>make</code> via Cygwin). Press "start" in Bochs, press enter in GRUB, and then Bochs will hang. Don't worry, that's because we put in an infinite loop. Just press shutdown. The output console will display the registers when Bochs shutdown. Check the value of EAX, which is the return value of our C function. Is it <code>deadbeef</code>? If so, good job, your code is working! If your code doesn't work, take a look at the code on <a href="https://github.com/cpancake/helios/tree/tut-2">GitHub</a> and see if you've done something wrong.</p>
<p>That's it for this tutorial. Next time, we'll get into displaying stuff on screen and other important bits. From this point on, all the code is available on <a href="http://github.com/cpancake/helios">GitHub</a>, so watch that repository if you want an update when I publish a new post. Until next time!</p>
  </div><!-- /.entry-content -->
</section>

<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'commiesprogblog'; 
    var disqus_title = 'OS Dev Environment Setup';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
    <footer id="contentinfo" class="body container">
        <address id="about" class="vcard body">
            <p>
                Written by <span class="fn">Andrew Rogers</span> (<span class="nickname">cpancake</span>) - contact me at <span class="email">andrew@<span class="email-obscure">lame-spam-bots-</span><span class="email-dont-obscure">anime-nigh</span>t.com</span>
            </p>
            <p>
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
            </p>
        </address><!-- /#about -->
    </footer><!-- /#contentinfo -->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-51284727-1', 'cpancake.github.io');
        ga('send', 'pageview');
    </script>
</body>
</html>